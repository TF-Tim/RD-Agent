# rdagent/scenarios/qlib/experiment/prompts.yaml

qlib_quant_background: |-
  Quantitative investment is a data-driven approach to asset management that relies on mathematical models, statistical techniques, and computational methods to analyze financial markets and make investment decisions. Two essential components of this approach are factors and models.
  
  You are one of the most authoritative quantitative researchers at a top Wall Street hedge fund. I need your expertise to develop new factors and models that can enhance our investment returns. Based on the given context, I will ask for your assistance in designing and implementing either factors or a model.

  {% if runtime_environment is not none %}
  ====== Runtime Environment ======
  You have following environment to run the code:
  {{ runtime_environment }}
  {% endif %}

qlib_factor_background: |-
  The factor is a characteristic or variable used in quant investment that can help explain the returns and risks of a portfolio or a single asset. Factors are used by investors to identify and exploit sources of excess returns, and they are central to many quantitative investment strategies.
  Each number in the factor represents a value for one instrument on one day.
  The user will train a model to predict the next several days' return based on prior factor values.
  Define the factor in the following parts:
  1. Name
  2. Description
  3. Formulation
  4. Variables (or functions) used in the formulation
  Please list all hyperparameters (e.g., window sizes, lookbacks, lags). One factor should statically define one output with a static source data. For example, last 10-day momentum and last 20-day momentum are two different factors.

  {% if runtime_environment is not none %}
  ====== Runtime Environment ======
  You have following environment to run the code:
  {{ runtime_environment }}
  {% endif %}

qlib_factor_interface: |-
  Your Python code must follow this interface to integrate with the user's system.
  ‚Ä¢ Structure: imports, function(s), and a main entry called "calculate_{function_name}" which is invoked under `if __name__ == "__main__":`.
  ‚Ä¢ Do NOT use try/except; the user captures exceptions.
  ‚Ä¢ Input data: an HDF5 file named "daily_pv.h5" (key="data") placed by the user. It contains a pandas DataFrame with a MultiIndex ['datetime','instrument'] and columns: "$open", "$close", "$high", "$low", "$volume", "$factor".
  ‚Ä¢ Output: write a single-column pandas DataFrame (index=['datetime','instrument'], column name exactly the factor name) to "result.h5" with key="data" in the same directory.

qlib_factor_strategy: |-
  MUST-FOLLOW rules for data schema, US equities, and saving:
  ‚Ä¢ Schema: Input HDF5 key is exactly "data". Index is a MultiIndex ['datetime','instrument'] (timezone-naive). Columns include "$open", "$close", "$high", "$low", "$volume", "$factor".
  ‚Ä¢ Use the dollar-prefixed field names (e.g., "$close"), NOT "close".
  ‚Ä¢ Grouped ops must respect per-instrument independence:
      # momentum example (10-day)
      m10 = df['$close'].groupby(level='instrument').pct_change(10)
  ‚Ä¢ Rolling ops add a group level; drop it:
      sma5 = (df['$close'].groupby(level='instrument').rolling(5).mean().droplevel(0))
  ‚Ä¢ Never force index alignment by assignment (e.g., `result.index = df.index`). Build the Series aligned to the original MultiIndex.
  ‚Ä¢ Handle infinities; keep NaNs from lookbacks:
      c = result.columns[0]
      result[c] = result[c].replace([float('inf'), float('-inf')], pd.NA)
  ‚Ä¢ Save EXACTLY:
      result.to_hdf("result.h5", key="data", mode="w")
  Notes:
  ‚Ä¢ The presence of "$factor" in input is required by the qlib schema even if your computation doesn‚Äôt use it directly.
  ‚Ä¢ The user will place "daily_pv.h5" in the working directory or a scenario-specific source folder so your script should load it by basename.

qlib_factor_output_format: |-
  Your output must be a pandas DataFrame like:
    <class 'pandas.core.frame.DataFrame'>
    MultiIndex: 40914 entries, (Timestamp('2020-01-02 00:00:00'), 'AAPL') to (Timestamp('2021-12-31 00:00:00'), 'MSFT')
    Data columns (total 1 columns):
    #   Column               Non-Null Count  Dtype
    ---  ------             --------------  -----
    0   your factor name    40914 non-null  float64
  Example (result.h5, key="data"):
    datetime    instrument
    2020-01-02  AAPL          -0.001796
                MSFT           0.005780
                GOOGL          0.004228
                AMZN           0.001298
                TSLA           0.005330
    ...
    2021-12-31  NVDA           0.000000
                META           0.002459
  The non-null count does not have to equal the total entries (lookback NaNs are expected).

qlib_factor_simulator: |-
  The produced factor will be consumed by qlib to train a model that predicts future returns based on prior factor values.
  Qlib supports varied ML paradigms (supervised, market dynamics, RL).
  The user‚Äôs pipeline will:
    1) Build a factor table from your "result.h5".
    2) Train a model (e.g., LightGBM, CatBoost, LSTM, simple PyTorch) to predict next-period returns.
    3) Construct a portfolio from predicted returns.
    4) Evaluate return, Sharpe, max drawdown, IC, etc.

qlib_factor_rich_style_description : |-
  ### R&D Agent-Qlib: Automated Quantitative Trading & Iterative Factors Evolution Demo
  #### Overview
  The demo showcases iterative hypothesis generation, knowledge construction, and decision-making, highlighting how financial factors evolve via continuous feedback and refinement.
  #### Automated R&D
  ‚Ä¢ Research: Iterative development of hypotheses
  ‚Ä¢ Development: Progressive factor implementation and validation
  #### Objective
  Demonstrate dynamic factor evolution in qlib, emphasizing improvements to accuracy and robustness.

qlib_factor_from_report_rich_style_description : |-
  ### R&D Agent-Qlib: Factor Extraction from Financial Reports Demo
  #### Overview
  Extract, implement, and evaluate factors from financial research reports; continuously expand/refine the factor library.
  #### Automated R&D
  ‚Ä¢ Research: Hypothesis mining from reports
  ‚Ä¢ Development: Automated implementation and testing
  #### Objective
  <table border="1" style="width:100%; border-collapse: collapse;">
    <tr><td>üí° <strong>Innovation</strong></td><td>Rapidly extract and test factors from reports.</td></tr>
    <tr><td>‚ö° <strong>Efficiency</strong></td><td>Identify promising factors faster.</td></tr>
    <tr><td>üóÉÔ∏è <strong>Outputs</strong></td><td>Grow the factor library for further research.</td></tr>
  </table>

qlib_factor_experiment_setting: |-
  | Dataset üìä | Model ü§ñ    | Factors üåü          | Data Split üßÆ |
  |------------|-------------|---------------------|---------------|
  | S&P 500    | LGBModel    | US Momentum (demo)  | Train: 2008-01-01 to 2014-12-31 <br> Valid: 2015-01-01 to 2016-12-31 <br> Test: 2017-01-01 to 2020-08-01 |

qlib_model_background: |-
  A model predicts returns/risks from factors. Provide:
  1) Name, 2) Description, 3) Architecture (layers/trees), 4) Hyperparameters,
  5) Training hyperparameters, 6) ModelType ("Tabular" or "TimeSeries").
  One model should statically define one output with fixed architecture/hyperparameters.

  {% if runtime_environment is not none %}
  ====== Runtime Environment ======
  You have following environment to run the code:
  {{ runtime_environment }}
  {% endif %}

qlib_model_interface: |-
  Provide a PyTorch `nn.Module` subclass with `__init__` and `forward`.
  Expose `model_cls` pointing to your class.
  ‚Ä¢ Tabular input shape: (batch_size, num_features)
  ‚Ä¢ TimeSeries input shape: (batch_size, num_timesteps, num_features)
  ‚Ä¢ Output shape for both: (batch_size, 1)
  Initialization:
    # tabular
    model = model_cls(num_features=num_features)
    # time series
    model = model_cls(num_features=num_features, num_timesteps=num_timesteps)
  Do not add other required ctor args. No try/except or `main` function.
  Use only current features as inputs; the user passes tensors to `forward`.

qlib_model_output_format: |-
  Your output is a tensor with shape (batch_size, 1).
  Save it as "output.pth" in the same directory as your Python file.
  The evaluator will check that the tensor in "output.pth" contains 8 numbers.

qlib_model_simulator: |-
  Models will be trained/evaluated in qlib; hypotheses will be iterated after evaluation.
  The pipeline will:
    1) Generate a baseline factor table,
    2) Train your `model_cls` to predict next-period returns from factors,
    3) Build a portfolio from predictions,
    4) Evaluate returns, IC, max drawdown, etc.,
    5) Iterate improvements based on feedback.

qlib_model_rich_style_description: |-
  ### Qlib Model Evolving Automatic R&D Demo
  #### Overview
  Iterative hypothesis and model development in quantitative finance.
  #### Automated R&D
  ‚Ä¢ Research: Ideation and learning
  ‚Ä¢ Development: Implementation and testing
  #### Objective
  Demonstrate dynamic model evolution in qlib, emphasizing accuracy and reliability.

qlib_model_experiment_setting: |-
  | Dataset üìä | Model ü§ñ     | Factors üåü          | Data Split üßÆ |
  |------------|--------------|---------------------|---------------|
  | S&P 500    | RDAgent-dev  | 20 factors (US set) | Train: 2008-01-01 to 2014-12-31 <br> Valid: 2015-01-01 to 2016-12-31 <br> Test: 2017-01-01 to 2020-08-01 |
